笔记



## 文本工具

### markdown

1. [教程连接](https://blog.csdn.net/qq_41261251/article/details/102817673?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166573797516782248561929%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166573797516782248561929&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-102817673-null-null.142^v56^control_1,201^v3^control&utm_term=Typora&spm=1018.2226.3001.4187)
2. [数学公式连接](https://blog.csdn.net/mingzhuo_126/article/details/82722455)
3. **创建表格**

+ Markdown 制作表格使用 `|` 来分隔不同的单元格，使用 `-` 来分隔表头和其他行。
  
+ ctrl+T 可以创建表格

| 11   | 222  | 333  |
| ---- | ---- | ---- |
| 1    | 1    |      |
|      |      |      |
|      |      |      |

2. **有关斜体**

   + *星号括住的字体是斜体*

   + _也可以用下横线，也是斜体_

   + *也可以用快捷键Ctrl+I也是斜体*

     

3. **有关加粗**

   + **双星号是加粗**
   + __双下横向也是加粗__
   + **CTRL+B也是加粗**

4. **标题**##

   + # 一级标题##

   + ## 二级标题####

   + ### 三级标题

   + ### 四级标题

   + ##### 五级标题

4. **有关加粗＋斜体**
   
   + ***三星号是加粗***
   + ___三下横向也是加粗___
   
5. **表示分割线**

   + 3个+ * _以上都是表示分割线

   + +++++++++

   + ****

   + ________

6. **文本高亮**

   + ====
   +  

6. **删除线**

   + ~~用双波浪线括住文本表示删除线~~
   + ~~也可以用选中文本，然后按下alt+SHIFT+5表示~~

7. **下划线**

   + ==<u>这样表示下划线，前后都需要有才表示</u>==
   + <u>也可以选中文本用ctrl+u表示</u>

8. **无序列表**
   + +后加空格
     * *
       - -

9. **有序列表**
   + 就是数字后面加.加空格就可以自动形成
   + 1. 这是第一节
        1. 第一节之后按下回车变成2.之后按下Tab就会变成第二节
        2. 按下回车就是当前的第二节增加
           1. 这是第3节
     2. 第二节如何退回第一节，操作如下在第二小节按下回车，退回X.之后，按下回车会删除X.，再按下回车则变回第一小节添加

10. **区块**

    > 这是区块
    >
    > 区块的表示>加空格就能形成
    >
    > 1. **如上关于字体的快捷键还是能使用在区块中**

13. **代码块**

    + 代码块的快捷键```3个上逗号后+编程语音+空格就能形成代码块

    ```c++
    ```

    
    
12. **链接**

    * [百度](https://www.baidu.com/)

    * 想要访问需要按着Ctrl，在用鼠标按下就能实现点击访问

    * [打开一张照片](./6e484dbb9fdc449e8ae57c5c2078f19.png)

    * ![本地png图片PictureTest.png](./6e484dbb9fdc449e8ae57c5c2078f19.png)

    * ![网络图片](http://static.runoob.com/images/runoob-logo.png "菜鸟教程")

    * ```c++
      [名字](链接)或者是<>括住链接也是超链接
      <https://www.baidu.com/>
      
      1. 也可以显示本电脑的其他文档
          [打开LinkTest.md文档](./LinkTest.md)
      	[打开LinkTest.png照片](./img/LinkTest.png)
          一个小圆点.表示当前目录，故./LinkTest.md表示当前目录下的LinkTest.md文件件，
          两个小圆点..表示上一级目录。
      2. ![本地png图片PictureTest.png](./img/PictureTest.png)
      
      ![本地jpg图片](./img/PictureTest.jpg)
      
      ![网络图片](http://static.runoob.com/images/runoob-logo.png "菜鸟教程")
      
      
      ```

13. **插入数学公式**

    + $$加上回车可以表示公式块 $\1+2$ 
      $$ {方法}
      1+2
      $$

    + 在公式块中用\\表示换行

    $$
    1+1=2\\
    2+2=3
    $$

    + `\sqrt{}`来表示根号,\sqrt[]{}来表示多少平方根
      $$
      \sqrt{2} + \sqrt[1]{6}
      $$

    + 用`\underline{}`,`\overline{}`来表示上下水平线
      $$
      \underline{a-b}\\c-f
      $$

    + 公式
      $$
      c(u)=\begin{cases} \sqrt\frac{1}{N}，u=0\\ \sqrt\frac{2}{N}， u\neq0\end{cases}
      \\波特率=\frac{系统时钟}{16\times(高低八位)}
      \\系统时钟16mkz,16\times10^6
      \\定时器周期=\frac{定时器分频\times计数次数}{系统时钟}
      \\例如，求计数次数，定时器分频为64,系统时钟为16MHZ,定时器周期为1ms
      \\计数次数=\frac{16\times10^6（系统时钟）\times1^{-3}（定时器周期）}{64(定时器分频)}
      $$
    
    
    
13. **改变字体颜色和大小<font size color>**

    + <font size=52 color="purple">zzofjf </font>
    + $\textcolor{red}{tar cjf kernel-modules.tar.bz2 -C modules lib}$
    + ![image-20230224092129062](.\image\image-20230224092129062.png)
    
17. **显示表情：emoji：**

18. **数学符号**

    + $ a_{1}+a_2\qquad x^2  x^{23}\qquad e^{-\alpha t}\qquad a^{32}_{ij}$

    + $ e^{tr}\qquad\qquad e^{x^2}\neq{e^x}^2$

19. **上下标**

    + H~2~O用~表示下标
    + X^1^用^表示上标
    
20. **快捷键**



### reStructuredText

1. 资料

   + [reStructuredText英文](https://docutils.sourceforge.io/rst.html)

     [介绍英文](https://docutils.sourceforge.io/docs/ref/rst/introduction.html)

     [快速开始英文](https://docutils.sourceforge.io/docs/user/rst/quickref.html)

     标记规范
     [英文](https://docutils.sourceforge.io/docs/ref/rst/restructuredtext.html)

     [中文](https://docutils-zh-cn.readthedocs.io/zh_CN/latest/ref/rst/restructuredtext.html)

     指令
     [英文](https://docutils.sourceforge.io/docs/ref/rst/directives.html)
     [中文](https://docutils-zh-cn.readthedocs.io/zh_CN/latest/ref/rst/directives.html)

     解释文本角色
     [英文](https://docutils.sourceforge.io/docs/ref/rst/roles.html)
     [中文](https://docutils-zh-cn.readthedocs.io/zh_CN/latest/ref/rst/roles.html)

     标准定义文件
     [英文](https://docutils.sourceforge.io/docs/ref/rst/definitions.html)

     [中文](https://docutils-zh-cn.readthedocs.io/zh_CN/latest/ref/rst/definitions.html)

### sphinx+Read the Docs

+ [sphinx参考网址](https://ebf-contribute-guide.readthedocs.io/zh_CN/latest/index.html)

+ 本地搭建环境执行如下命令

+ ```text
   sudo apt install git
   sudo apt install make
   sudo apt install python3
   sudo apt install python3-pip 
   
   pip3 install -U Sphinx
   pip3 install sphinx-autobuild
   pip3 install sphinx_rtd_theme
   pip3 install recommonmark
   pip3 install sphinx_markdown_tables
  ```





![image-20230606164526295](.\image\image-20230606164526295.png)



**conf.py**

+ 修改的html_theme = 'sphinx_rtd_theme' 修改中间内容进行修改主题，网页的格式不一样
+ 2.

![image-20230606111306265](.\image\image-20230606111306265.png)

### reText

1. 下载并安装Python python-3.10.10-amd64.exe

+ [下载参考](https://blog.csdn.net/weixin_56744600/article/details/124707124?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167841569716800213045290%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167841569716800213045290&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-124707124-null-null.142^v73^control_1,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=python%E4%B8%8B%E8%BD%BD&spm=1018.2226.3001.4187)

+ 配置环境变量

  ```shell
  变量名：PYTHONPATH
  
  变量值：E:\Python34\Lib\;E:\Python34\Lib\site-packages\
  
  变量值请根据自己实际的安装路径适当修改，你懂的哈。
  
  同理继续添加QT_QPA_PLATFORM_PLUGIN_PATH系统变量
  
  变量名：QT_QPA_PLATFORM_PLUGIN_PATH
  
  变量值：E:\Python34\Lib\site-packages\PyQt5\plugins\platforms
  
  然后选中Path系统环境变量，然后点“编辑”，在变量值最前面添加上：
  
  E:\Python34;E:\Python34\Lib\site-packages\PyQt5;
  ```

2. 下载retext压缩包 retext-master.zip

3. 打卡cmd,去到python 安装的路径

+ ```shell 
  cd E:\Python34
  pip install PyQt6
  pip install PyQt5
  cd E:\Python34\Scripts
  pip install Pygments
  pip install Markdown
  pip install docutils
  pip install Markups
  ```

4. 双击retext压缩包里的，retext.py就能运行

  



## 裸机

### 波特率

$$
波特率=\frac{系统时钟}{16\times(高低八位)}
   \\如果系统时钟是16mkz,则计算时需要写成16\times10^6
   \\定时器周期=\frac{定时器分频\times计数次数}{系统时钟}
   \\例如，求计数次数，定时器分频为64,系统时钟为16MHZ,定时器周期为1ms
   \\计数次数=\frac{16\times10^6（系统时钟）\times1^{-3}（定时器周期）}{64(定时器分频)}
$$

### 输入输出

对于MCU来说：控制是输出，被控制是输入（例如按键，串口接收都是输入，串口发送数输出）

### 冒泡排序

检测dac的时候用冒泡

```c
uint16_t MaoPao_adc(uint8_t u8channel)
{
	 uint16_t Bat_buf[10];
	 uint16_t i,j,k,u16data; 
    for( i = 0; i <10; ++i)
    {
        Bat_buf[i] = GET_ADC_DATA(u8channel);
				
    }
     //从小到大排序
    for(j = 0 ; j <10-1; ++j)
    {
        for(k = 0; k <10-j-1; ++k)
        {
            if(Bat_buf[k] > Bat_buf[k+1])
            {
                u16data = Bat_buf[k];
                Bat_buf[k] = Bat_buf[k+1];
                Bat_buf[k+1] = u16data;
            }
        }
    }
	return Bat_buf[(10 - 1)/2];
}
```



### 位移倒装

1. 呈现的结果

​		1110 1010--->0101 0111

2. C语言的具体实现

``` c
UINT8 Reverse_byte(UINT8 u8data){
    UINT8 temp=0x00;
    UINT8 i;
    for(i=0;i<8;i++){
        temp = ((u8data>>i)&0x01)|temp;
        if(i<7){
            temp = temp<<1;
        }
    }
    //temp = temp<<4;
  return temp;
}
```



## cherryUSB

1. [check.h](https://libcheck.github.io/check/doc/doxygen/html/check_8h.html#a0085fc05eba2e9048822aa93aeebc2d2)
2. [CherryUSB](https://cherryusb.readthedocs.io/zh_CN/latest/)



### 设备协议栈的切入点

​	USB中断：状态中断：复位，挂起、恢复、 VBUS 

​	端点中断：端点0中断 、其他端点中断 

​	其他中断 sof中断、错误中断

### 端点

端点0 ：是一个双向的断点，setup中断，out中断、in中断



### 事务

setup事务：发送



### 描述符

设备描述符



接口描述符









































## LWIP

1. [官网](https://www.nongnu.org/lwip/2_1_x/pitfalls.html)

 





















## MQTT协议

1. IBM公司开发的

2. 有3种消息发布服务质量 QoS0、 QoS1、 QoS2。

   +  QoS0：表示”至多一次“，会发生小时丢失或重复。

   + QoS1：表示“至少一次”，确保消息到达，但消息可能重复发生。
   + QoS2：表示“只有一次”，确保消息只到达一次。

3. 主题模式：

4. 报文格式

    +  报文的格式
    +  ![image-20230724153337596](.\image\image-20230724153337596.png)
    +  固定报头的格式

![image-20230724153317199](.\image\image-20230724153317199.png)

![image-20230724154134748](.\image\image-20230724154134748.png)



+ 






























## RTOS

### RT-Thread

1. [官网](https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/README)



#### 启动

![image-20230609143736293](.\image\image-20230609143736293.png)

![image-20230609143623897](.\image\image-20230609143623897.png)



#### 导出到msh命令列表

+ 导出到msh命令列表，就是相当于定义了一个命令，命令调用函数，函数执行内容，在msh模式下，就类似于在Linux环境下执行命令

+ **MSH_CMD_EXPORT(name, desc):** 【name】=要导出的命令，【desc】:命令解析

+ **MSH_CMD_EXPORT_ALIAS(函数，name, desc)**：【函数】：命令调用的函数，【name】：要导出的命令，【desc】:命令解析

  ![image-20230609164526073](.\image\image-20230609164526073.png)

#### 时钟管理

1. 获取时钟节拍
	```c
	rt_tick_t rt_tick_get(void);
	```



#### 内存

+ 初始化要设置内存的大小

  + 内存的开始地址，内存的结束地址

  + ```c
    void rt_system_heap_init(void* begin_addr, void* end_addr);
    ```

+ 分配内存

  + 分配的大小

  + ```c
    void *rt_malloc(rt_size_t nbytes);
    //例子：
    int *A;
    A=rt_malloc(102);
    ```

+ 释放内存

  + 需要释放的指针

  + ```c
    void rt_free (void *ptr);
    //例子：
    rt_free(A);
    ```

+ 重新分配

  + 重新分配的指针，大小

  + 如果大小减小了，则截断尾部的数据，如果增大则在尾部增加

  + ```c
    void *rt_realloc(void *rmem, rt_size_t newsize);
    //例子：
    B=rt_realloc(A,145)
    //也可以
    A=rt_realloc(A,145)   
    ```

#### 线程

1. 线程创建
1. 怎么保存线程
1. 线程的状态切换
1. ![image-20230612102148656](.\image\image-20230612102148656.png)


2. 初始化动态线程对象
 ```c
 rt_thread_t rt_thread_create(const char* name,  //名字
                               void (*entry)(void* parameter), //名字
                               void* parameter,				//事件
                               rt_uint32_t stack_size,
                               rt_uint8_t priority,//0-31
                               rt_uint32_t tick);
 ```
3. 静态线程对象

   ```c
   rt_err_t rt_thread_init(struct rt_thread* thread,//名字
                           const char* name,			//名字
               void (*entry)(void* parameter), 		//事件
                           void* parameter,			//事件参数
                           void* stack_start,			//线程栈起始地址
                           rt_uint32_t stack_size,	//线程栈大小，单位是字节
                           rt_uint8_t priority, 	//优先级
                           rt_uint32_t tick);		//时间片
   ```
   
   
   
3. 设置空闲线程函数

   ```c
   rt_err_t rt_thread_idle_sethook(void (*hook)(void));
   rt_err_t rt_thread_idle_delhook(void (*hook)(void));
   ```

初始状态：rt_thread_create（）；

启动函数rt_thread_startup（）；

就绪状态/运行状态

挂起状态rt_thread_suspend();

关闭状态





## 汇编指令

1. 读取内存指令： LDR  R0  [R3]

​					表示去R3表示的内存，读data放入R0中

2. 写内存指令：STR R0 [R3]

   ​			表示

3. 加指令 ：ADD

4. 减指令

5. 栈:高地址在上面，低地址在下面 

   push {R0.R2}



### 温馨提示

1. 为了避免有些线程执行无效的代码，可以让某些线程执行休眠，条件满足的时候才去唤醒线程
2. 要注意各种链路之间的关系有没有依赖，还有有关于抢占的





## 匠心创sdk

### 引脚的应用

![image-20230710172504359](.\image\image-pin.png)

### 视频大小的设置

![image-20230721165252592](.\image\image-vedio.png)











## LVGL

### LVGL模拟器操作步骤

1. 下载vscode2019版本

   + https://learn.microsoft.com/zh-cn/visualstudio/releases/2019/release-notes
   + ![image-20230616102839108](.\image\image-20230616102839108.png)

   + 安装的时候选上下图
   + ![image-20230616103610400](.\image\image-20230616103610400.png)

2. 下载LVGL文件

   + [lv_sim_visual_studio](https://github.com/lvgl/lv_port_pc_visual_studio)
   + [lvgl](https://github.com/lvgl/lvgl)
   + [lv_demos](https://github.com/lvgl/lv_demos)
   + [lv_drivers](https://github.com/lvgl/lv_drivers)
   + [lv_lib_freetype](https://github.com/lvgl/lv_lib_freetype)
   + [freetype](https://github.com/freetype/freetype)
   + 都整合好了放在了百度云盘，如果太慢可以自己重新下载

3. 存放文件
   + 把刚刚下载好lvgl和freetype放入lv_sim_visual_studio
   + ![image-20230616104344598](.\image\image-20230616104344598.png)

4. 编辑工程
   + ![image-20230616104847503](.\image\image-20230616104847503.png)
   + 选择工程编辑属性
   + ![image-20230616104623891](.\image\image-20230616104623891.png)
   + 在属性中选择对应的
   + ![image-20230616104705104](.\image\image-20230616104705104.png)

### LVGL图层概念

+ 总结参看这个网址
  + https://blog.csdn.net/zhoutaopower/article/details/124600340

### LVGL有关函数的使用

#### 学习网址

+ [lvgl+freertos](https://blog.csdn.net/believe666?type=blog)
+ [LVGL](https://blog.csdn.net/pq113_6?type=blog)
+ [中文资料](http://lvgl.100ask.net/8.2/intro/index.html)
+ [英文资料](https://docs.lvgl.io/8.3/index.html)

#### 1. 初始化设置

+ **lv_img_cache_set_size(X);:**设置要缓存的图像数量

#### 2. 设置控件的位置

  ```c
  //有关控件位置的函数
  void lv_obj_set_x(struct _lv_obj_t * obj, lv_coord_t x);
  void lv_obj_set_y(struct _lv_obj_t * obj, lv_coord_t y);
  void lv_obj_center(struct _lv_obj_t * obj);
  void lv_obj_set_pos(struct _lv_obj_t * obj, lv_coord_t x, lv_coord_t y);
  void lv_obj_align_to(struct _lv_obj_t * obj, const struct _lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs);
  ```

+ **lv_obj_align():** :控件的位置

  + ```cpp
    //参数说明
    struct _lv_obj_t * obj：要设置的对象指针
    onst struct _lv_obj_t * base ：设置对象的对齐方式
    lv_coord_t x_ofs ：设置对齐方式的x坐标的偏移方向
    lv_coord_t y_ofs ：设置对齐方式的y坐标的偏移方向
    
    //例子    
    lv_obj_align(rect, LV_ALIGN_TOP_LEFT, 0, 0);
    lv_obj_align(rect, LV_ALIGN_TOP_MID, 0, 0);
    ```
    
  + 对齐方式的参数位置指导

  + ![a8a5ea8f33ccdda9759e04d70281a98f](.\image\a8a5ea8f33ccdda9759e04d70281a98f.png)

#### 3. 控件的大小

```c 
void lv_obj_set_width(lv_obj_t * obj, lv_coord_t w);
void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h);
void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h);
```

+ LV_PCT(50),像素（数字）。

  百分比（LV_PCT(x)）是以对象或其父对象的大小的百分比，LV_PCT会把数字转化为百分比。

+ ```c
  //例子
  lv_obj_set_size(rect, LV_PCT(20), LV_PCT(20));
  ```

#### 4. 父子关系

+ 更改对象的父对象
+ ```cpp
  void lv_obj_set_parent(struct _lv_obj_t * obj, struct _lv_obj_t * parent);
  struct _lv_obj_t * obj ：子
  struct _lv_obj_t * parent ：父
  ```

  + 当对象指定了父，对象所设定的位置是相对父来说的

+ 获取父对象
+ ```cpp
  struct _lv_obj_t * lv_obj_get_parent(const struct _lv_obj_t * obj);
  ```

  + 付对象是SCreen则会返回NULL

+ 例子代码

```c
  lv_obj_t *rect = lv_obj_create(lv_scr_act());
  lv_obj_set_size(rect, LV_PCT(50), LV_PCT(50));
  lv_obj_align(rect, LV_ALIGN_CENTER, 0, 0);

  lv_obj_t *rect1 = lv_obj_create(lv_scr_act());
  lv_obj_set_size(rect1, LV_PCT(20), LV_PCT(20));
  lv_obj_align(rect1, LV_ALIGN_TOP_LEFT, 0, 0);

  lv_obj_set_parent(rect1,rect);
```

+ 效果

![image-20230615150102568](.\image\image-20230615150102568.png)



#### 5. 样式（图片）

+ 理解：样式就是对组件的背景之类进行设置

1. 初始化样式

```c
static lv_style_t style;
lv_style_init(&style);
```

2. 设置样式

```c 
lv_style_set_<property_name>(&style, <value>);
```

+ 参照第4点

3. 添加样式

```c
void lv_obj_add_style(struct _lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector);
void lv_obj_remove_style(struct _lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector);
```


4. 具体有关于设置样式的其他函数
   + 实际有很多设置样式的函数，更多要查看官网的资料，常用的如下
```c
void lv_style_set_bg_color(lv_style_t * style, lv_color_t value);			//设置背景颜色
void lv_style_set_bg_color_filtered(lv_style_t * style, lv_color_t value);	//设置背景过滤颜色
void lv_style_set_bg_opa(lv_style_t * style, lv_opa_t value);				//设置背景透明度
void lv_style_set_bg_grad_color(lv_style_t * style, lv_color_t value);		//设置背景下半部颜色
void lv_style_set_bg_grad_color_filtered(lv_style_t * style, lv_color_t value);//设置背景下半部过滤颜色
void lv_style_set_bg_grad_dir(lv_style_t * style, lv_grad_dir_t value);		//设置背景下半部颜色填充方向
void lv_style_set_bg_main_stop(lv_style_t * style, lv_coord_t value);		//主色停止
void lv_style_set_bg_grad_stop(lv_style_t * style, lv_coord_t value);		//下半部色停止
void lv_style_set_bg_img_src(lv_style_t * style, const void * value);		//设置背景图片
void lv_style_set_bg_img_opa(lv_style_t * style, lv_opa_t value);			//设置背景图片透明度
void lv_style_set_bg_img_recolor(lv_style_t * style, lv_color_t value);		//设置背景图片重着色
void lv_style_set_bg_img_recolor_filtered(lv_style_t * style, lv_color_tvalue);//设置背景图片重着色过滤色
void lv_style_set_bg_img_recolor_opa(lv_style_t * style, lv_opa_t value);	//设置背景图片重着色透明度
void lv_style_set_bg_img_tiled(lv_style_t * style, bool value);				//设置背景图片平铺

```

+ 例子应用

```c
static lv_style_t style;                          //创建样式         
lv_style_init(&style);                          //初始化样式
lv_style_set_radius(&style, 5);                 //设置圆角半径
    
LV_IMG_DECLARE(pre_press);                     //加载图片声明 .c文件的图片
lv_style_set_bg_img_src(&style, &pre_press);	//设置背景图片
lv_style_set_bg_img_opa(&style, LV_OPA_50); 	//设置背景图片透明度
lv_style_set_bg_img_recolor(&style, lv_palette_main(LV_PALETTE_RED));//设置背景图片重着色
lv_style_set_bg_img_recolor_opa(&style, LV_OPA_40);	//设置背景图片重着色透明度
lv_style_set_bg_img_tiled(&style, false);			//设置背景图片平铺

/*Create an object with the new style*/
lv_obj_t* obj = lv_obj_create(lv_scr_act());   //创建对象
lv_obj_add_style(obj, &style, 0);              //设置对象的样式
lv_obj_set_size(obj,200,200);				   //设置对象的尺寸
lv_obj_center(obj);                            //居中对象
```

+ <font color="redpink">注意：图片的路径要确认正确，不然**LV_IMG_DECLARE**会报错</font>



#### 6. 主题

+ 

```cpp
lv_theme_t  * lv_theme_get_from_obj(lv_obj_t * obj);
```



#### 7. 工具栏的创建

1. 创建函数

   ```c
   //函数 
   lv_obj_t *lv_tabview_create(lv_obj_t *parent, lv_dir_t tab_pos, lv_coord_t tab_size)
   //例子
   lv_obj_t* tabview = lv_tabview_create(lv_scr_act(), LV_DIR_TOP, 80);
   ```

2. ```c
           lv_obj_t* tabview = lv_tabview_create(lv_scr_act(), LV_DIR_TOP,30);     //  在顶端设置一个工具栏，
           lv_obj_set_style_text_font(lv_scr_act(), font_normal, 0);
           lv_obj_t* btn = lv_tabview_get_tab_btns(tabview);
           lv_obj_set_style_bg_color(btn, lv_palette_darken(LV_PALETTE_GREEN, 1), 2); //把工具栏设置为按键类型
           lv_obj_set_style_pad_left(btn, LV_HOR_RES / 2, 0);
           lv_obj_t* logo = lv_img_create(btn);
           LV_IMG_DECLARE(img_lvgl_logo);
           lv_img_set_src(logo, &img_lvgl_logo);
           lv_obj_align(logo, LV_ALIGN_LEFT_MID, -LV_HOR_RES / 2 + 25, 0);
            
           lv_obj_t * label = lv_label_create(btn);
           lv_obj_add_style(label, &style_title, 0);
           lv_label_set_text(label, "LVGL v8");
           lv_obj_align_to(label, logo, LV_ALIGN_OUT_RIGHT_TOP, 10, 0);
            
           label = lv_label_create(btn);
           lv_label_set_text(label, "Widgets demo");
           lv_obj_add_style(label, &style_text_muted, 0);
           lv_obj_align_to(label, logo, LV_ALIGN_OUT_RIGHT_BOTTOM, 10, 0);

   

           lv_obj_t* tab1 = lv_tabview_add_tab(tabview, "lili");
           lv_obj_t* tab2 = lv_tabview_add_tab(tabview, "gigi");
           analytics_create(tab1);



#### 8.文本框+键盘

1. 创建文本框

   ```c
    lv_obj_t *lv_textarea_create(lv_obj_t *parent)
   ```

2. 添加与删除文本框字符

   ```c
   //添加单个字符
   void lv_textarea_add_char(lv_obj_t *obj, uint32_t c)
   //添加字符串
   void lv_textarea_add_text(lv_obj_t *obj, const char *txt)
   //删除光标左边字符
   void lv_textarea_del_char(lv_obj_t *obj)
   //删除光标右边字符
   void lv_textarea_del_char_forward(lv_obj_t *obj)
   ```

3. 具体详细可以查看官网

   [有关lvgl文本框的中文内容](http://lvgl.100ask.net/8.2/widgets/core/textarea.html)

   [文本框的全部函数](https://docs.lvgl.io/master/API/widgets/textarea/lv_textarea.html#lv-textarea-h)

4. **具体的应用**

```c 
static lv_obj_t* kb;
static lv_obj_t* btn2;
static lv_obj_t* label2;


typedef struct btn_usr_data
{
    lv_obj_t* obj_ta_blue;
    
}btn_usr_data_t;

// 按键回调函数
static void btn_event_callback(lv_event_t* event)
{
    lv_obj_t* btn = lv_event_get_target(event);

    if (event == NULL)
    {
        printf("[%s:%d] event is NULL\n", __FUNCTION__, __LINE__);
        return;
    }

    lv_event_code_t code = lv_event_get_code(event);
    if (code == LV_EVENT_CLICKED)
    {
        btn_usr_data_t* data = (btn_usr_data_t*)lv_event_get_user_data(event);
        if (data == NULL)
        {
            return;
        }

        char* r = lv_textarea_get_text(data->obj_ta_blue);

        lv_obj_t* label = lv_obj_get_child(btn, 0);
        lv_label_set_text_fmt(label, " %s", r);
    }
}

static void ta_event_cb22(lv_event_t* e)
{
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t* ta = lv_event_get_target(e);
    //按下键盘的按键，对应显示在文本框中
    if (code == LV_EVENT_CLICKED || code == LV_EVENT_FOCUSED) {
        if (kb != NULL) lv_keyboard_set_textarea(kb, ta);
    }
    //按下回车按键，把文本框的内容显示在btn2按键上
    else if (code == LV_EVENT_READY) {
        LV_LOG_USER("Ready, current text: %s", lv_textarea_get_text(ta));

        char* r = lv_textarea_get_text(ta);

        label2 = lv_obj_get_child(btn2, 0);
        lv_label_set_text_fmt(label2, " %s", r);

    }
}


void lv_demo_widgets(void)
{

    if (LV_HOR_RES <= 320) disp_size = DISP_SMALL;
    else if (LV_HOR_RES < 720) disp_size = DISP_MEDIUM;
    else disp_size = DISP_LARGE;

    font_large = LV_FONT_DEFAULT;
    font_normal = LV_FONT_DEFAULT;

    lv_coord_t tab_h;
    tab_h = 45;

    //创建一个按键
    btn2 = lv_btn_create(lv_scr_act());
    lv_obj_set_pos(btn2, 10, 10);
    lv_obj_set_size(btn2, 120, 50);
    lv_obj_align(btn2, LV_ALIGN_TOP_LEFT, 330, 100);           //按键位置

    //创建一个label
    label2 = lv_label_create(btn2);
    lv_label_set_text(label2, "");
    lv_obj_center(label2);           //label位置 创建是根据按键创建的，设置位置为中心，是在按键的中心

    //创建文本输入框
    lv_obj_t* obj_ta_blue = lv_textarea_create(lv_scr_act());
    //文本框内容
    static btn_usr_data_t data = { 0 };
    lv_textarea_set_one_line(obj_ta_blue, true);                                         // 设置文本输入框为1行
    lv_textarea_set_text_selection(obj_ta_blue, true);                                   // 设置文本框可选中
    //lv_textarea_set_accepted_chars(obj_ta_blue, "0123456789");                         // 设置文本输入框可输入的字符
   // lv_textarea_set_max_length(obj_ta_blue, 3);                                        // 设置文本输入框可输入的字符最大长度
    lv_obj_set_style_radius(obj_ta_blue, 0, 0);                                          // 圆角大小
    lv_obj_set_size(obj_ta_blue, 150, 50);                                               // 文本框大小
    lv_obj_align(obj_ta_blue, LV_ALIGN_TOP_LEFT, 330, 0);                                // 文本框位置
    lv_obj_set_style_text_font(obj_ta_blue, (const lv_font_t*)&lv_font_montserrat_20, 0);// 文本字体大小
    lv_obj_set_style_bg_opa(obj_ta_blue, LV_OPA_50, LV_PART_MAIN);                       // 设置文本框背景颜色
    lv_obj_set_style_border_color(obj_ta_blue, lv_color_hex(0xFF0000), LV_PART_MAIN);    // 设置文本框边框
    lv_textarea_add_text(obj_ta_blue, "abc");                                            // 添加字符串到文本框
    lv_textarea_add_char(obj_ta_blue, 'a');                                              // 添加单个字符在文本框
    data.obj_ta_blue = obj_ta_blue;                                                      // 得到文本框数据
    lv_obj_add_event(btn2, btn_event_callback, LV_EVENT_CLICKED, (void*)&data);          // 按键事件
    lv_obj_add_event(obj_ta_blue, ta_event_cb22, LV_EVENT_ALL, NULL);                    // 文本框事件

    //键盘
    kb = lv_keyboard_create(lv_scr_act());
    lv_obj_set_size(kb, LV_HOR_RES, LV_VER_RES / 2);


}
```

**代码应用成果**

![image-LVGL_text](.\image\image-LVGL_text.png)





#### 9.中文显示 

1. [在线中文转换工具](https://lvgl.io/tools/fontconverter)
2. [中文字体包下载](http://lvgl.100ask.net/8.2/tools/fonts-zh-source.html)
3. ![image-20230621154907804](.\image\image-20230621154907804.png)

```c
//例子如下   
lv_obj_t* canxiankuang = lv_obj_create(lv_scr_act());
    lv_obj_set_size(canxiankuang, 200, 40);
    lv_obj_align(canxiankuang, LV_ALIGN_TOP_RIGHT, 0, 52);

    LV_FONT_DECLARE(tital);
    lv_obj_add_style(canxiankuang, &style, LV_STATE_DEFAULT);
    const char* str2 = "产线：";
    lv_obj_t* canxian = lv_label_create(canxiankuang);
    lv_obj_center(canxian);
    lv_label_set_text(canxian, str2);
    lv_obj_set_style_text_font(canxian, &tital, 0);
    lv_obj_set_style_text_color(canxian, lv_color_make(0xff, 0xff, 0xff), 0);
```



#### 10.下拉选项框

```c
static void dd_event_handler(lv_event_t* e)
{
    lv_event_code_t code = lv_event_get_code(e);
    lv_obj_t* obj = lv_event_get_target(e);

    if (code == LV_EVENT_VALUE_CHANGED)
    {
        LV_LOG_USER("%d", lv_dropdown_get_selected(obj));       // 获取选项的索引值，从0开始
        char tmp_buf[32];
        lv_dropdown_get_selected_str(obj, tmp_buf, sizeof(tmp_buf)); // 获取选项的内容
        LV_LOG_USER("%s", tmp_buf);
    }
    else if (code == LV_EVENT_CLICKED)
    {
        // 【方法2】在运行时进行修改
        // 改变下拉列表中列表的样式
        // 这些修改可以在初始化的时候就设置好，你也可以像下面这样动态地修改样式
        lv_obj_t* dd_list = lv_dropdown_get_list(obj);
        if (dd_list != NULL)
        {
            // 需要在 lv_conf.h 中打开宏 LV_FONT_MONTSERRAT_28，要使用其他内置字体同理
            // 注意：如果你初始化时使用了中文字库，并且设置了中文选项，这里设置之后内容将不能展示出来
            //lv_obj_set_style_text_font(dd_list, &lv_font_montserrat_28, 0);

            // 修改列表的背景颜色
            // 这里只修改颜色，你还可以修改其他样式属性
            lv_obj_set_style_bg_color(dd_list, lv_color_hex(0xc43e1c), 0);
            //lv_obj_set_style_bg_color(dd_list, lv_color_hex(0xc43e1c), LV_PART_MAIN); // 这样写和上面那个是一样的

            // 修改滚动条的样式
            // 这里只修改颜色，你还可以修改其他样式属性
            lv_obj_set_style_border_color(dd_list, lv_color_hex(0xcc3e1c), LV_PART_SCROLLBAR);

            // 修改当按下、选中或按下+选中选项时的样式
            // 这里只修改颜色，你还可以修改其他样式属性
            lv_obj_set_style_bg_color(dd_list, lv_color_hex(0xafbeac), LV_PART_SELECTED);

        }
    }
}

void lv_100ask_demo_course_3_6_1(void)
{
    /* 创建一个 lv_dropdown 部件(对象) */
    lv_obj_t* dd = lv_dropdown_create(lv_scr_act());    // 创建一个 lv_dropdown 部件(对象),他的父对象是活动屏幕对象

    lv_dropdown_set_options(dd, "1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n4\n5\n6\n7\n8\n9\n10");  // 写法1：添加选项，索引从0开始

    lv_obj_center(dd);                                    // 方法1：让对象居中，简洁
    //lv_obj_align(dd, LV_ALIGN_CENTER, 0, 0);            // 方法2：让对象居中，较为灵活


    // 添加事件
    // 当我们点击下拉列表时，会触发 LV_EVENT_CLICKED 事件类型，并且会创建出一个列表，列表中展示我们在前面设置的选项供我们选择
    // 当我们选中一个选项时，会触发 LV_EVENT_VALUE_CHANGED 事件类型
    lv_obj_add_event(dd, dd_event_handler, LV_EVENT_ALL, NULL);
}
```











## 开发工具

### bat

1. 开头必须是@echo off/on
2. echo on![image-20230313174843292](.\image\image-20230313174843292.png)
3. echo off![image-20230313175033762](.\image\image-20230313175033762.png)

### bash

+ echo +$名字，可以查
+ 文件路径自动补全
+ ctrl + L 清空
+ pstree
+ 



### vim

<font size=5>**1. 使用vim打开文件**</font>

+ 命令界面输入**vim  文件名**，没有此文件会在对应的目录下创建文件，有则直接打开

<font size=5>**2. Command模式和edit模式**</font>

+ Command-->edit  按下按键 **i**;
+ edit -->Command按下**Esc**;
+ 保存退出Command输入**：wq** ；**w**:是保存；**q**：退出
+ 不保存退出Command 输入**:q!**



<font size=5>**3.visual模式**</font>

+ Command-->visual  按下按键 **v**;
+ visual -->Command按下**Esc**;



<font size=5>**4.末行模式**</font>

+ Command模式下按下   **：**



<font size=5>**5. 在Command模式下光标跳转**</font>

+ 移动光标 按键**H**:←    **J**:↓        **K**：↑          **L**：→ 
+ **W**:跳动到下一个单词  **B**：往前跳一个单词 
+ **page up和ctrl+f**: 跳转到下一页  **page down和ctrl+b** 跳转到上一页 
+ **XXgg** 跳转到XX行    **XXj** 往下跳xx行       **xxk** 往上跳xx行
+ **/word**  跳转到对应的字   **N ** 下一个  **shift+n** 上一个
+ 光标处输入 **yy**复制一整行   **cc** 剪切一整行保留回车    **dd**剪切单行不保留回车   **p**粘贴  
  	+ yy  cc dd 中间加数字表示几行     例如 **y2y**复制2行
+ **u**撤回操作 
+ **v**视图模式多行选择，选中之后按下c/y执行剪切或复制







<font size=5>**6. 代码方式设置**</font>

+ 都是在Command模式下输入
+ 高亮命令模式下输入**:syntax on**
+ 设置代码前的数字输入**:set number**



<font size=5>**7.vim插件**</font>

+ ctrl+w窗口跳转
+ ctrl+n代码自动补全
+ vimrc是vim的配置文件
+ 第三方插件管理vimplug
+ + 在GitHub搜索vimplug即可，在根目录下输入下面命令
  + https://github.com/junegunn/vim-plug
  + 选择对应的操作系统的相关下载命令， 在跟根目录下输入命令
  + <img src=".\image\image-20230202095405211.png" style="zoom:80%;" />
  + vim plug 的使用说明在.vimrc 中 使用前加上call plug#begin() 结束call plug#end()，中间加上plug插件的对应的语句
  + <img src=".\image\image-20230202100624301.png" alt="image-20230202100624301" style="zoom:80%;" />
  + 
+ vimswesome   vim收录插件的网址https://vimawesome.com/
+ 选择vimplug  根据提示在.vimrc上写下对应的语句

![image-20230202100120791](.\image\image-20230202100120791.png)

![image-20230202100425597](.\image\image-20230202100425597.png)

+ 最后打开vimCommand模式下数据:PlugInstall进行安装NERDTree
+ NERDTree 的帮助文档，在Command模式下输入：help NERDTree查看
+ 设置NERDTree自动打开
+ 在vimrc 加上 Autocmd VimEnter * NERDTree
+ 删除注释以上添加的命令 ![image-20230202101632267](.\image\image-20230202101632267.png)
+ 完全删除在vim :PlugClean完全删除



### pandoc

1. [所有文件转换格式文档](https://pandoc.org/demos.html#)
2. pandoc MYIMX8MPEK314-QSG.快速开始.md -f markdown -t rst -s -o MYIMX8MPEK314-QSG.快速开始.rst



### Sphinx

1. [官方网站](https://www.sphinx-doc.org/en/master/)

1. 克隆下文件

git clone https://github.com/hi-tangbin/myzr-docs.git

 df -h

git status .

cd myzr-docs/

sudo apt-get install -y sphinx-doc sphinx-common

sphinx-autobuild . _build/html

pip install sphinx_rtd_theme

cd _build/html/

sphinx-autobuild . _build/html --host=172.16.128.82 --port=8000

执行完之后出现报错，并且打开172.16.128.82是404

![image-20230316114948682](.\image\image-20230316114948682.png)

就需要在conf.py添加上

sphinx error:

masrer file

master_doc = 'index'

![image-20230316115140314](.\image\image-20230316115140314.png)

再执行sphinx-autobuild . _build/html --host=172.16.128.82 --port=8000。网页就能登上

![image-20230316144235768](.\image\image-20230316144235768.png)

markdown 文件在sphinx上显示

执行：

pip install -i https://mirrors.aliyun.com/pypi/simple/  -U sphinx_rtd_theme
pip install -i https://mirrors.aliyun.com/pypi/simple/  -U recommonmark
pip install -i https://mirrors.aliyun.com/pypi/simple/  -U sphinx_markdown_tables
pip install -i https://mirrors.aliyun.com/pypi/simple/  -U sphinxprettysearchresults



修改conf.py文件 extensions = ['recommonmark']

source_suffix ={

  '.rst':'restructuredtext',

  '.md':'markdown'，

}

![image-20230316144412469](.\image\image-20230316144412469.png)

添加md文件

在index.rst中添加文件名

再重新执行

sphinx-autobuild . _build/html --host=172.16.128.82 --port=8000



在vc中添加远程资源文件

![image-20230316150228106](.\image\image-20230316150228106.png)

#### 解决问题







### shell

####  1.shebang

+ 意思：是由#！组成，在文件的第一行，后面的内容指的是用什么解释器
+ #! /bin/bash  sh文件的解释器
+ #！/usr/bin/python py文件的解释器
+ 当shebang指定错误，可以手动指定

![image-20230328170040840](.\image\image-20230328170040840.png)

#### 2. 执行脚本

+ ./ 使用相对/绝对 执行
+ source 执行

#### 3.shell变量

1. 弱类型语言，shell语音定义的变量，**数据类型都是默认字符串类型**

2. 定义变量不能有空格，**定义变量只能是字母，数字，下划线，不能用数字开头，可以用下划线开头**如：

   + zhong_222
   + _zhong222
   + ~~222_zhong~~ 错误
   + ~~zhong 3333~~错误

3. 取值 `echo '$'{变量}`，变量区分大小写；

   中括号可以省略 `echo $`

#### 4.变量的作用域

+ 父子shell，变量的使用区域

#### 5. 符号的用途

+ 双引号，能识别特殊符号

+ 单引号，不能识别特殊符号，所见即所得

+ 反引号，引用命令执行结果

+ 反斜杠，是转义符号的概念

![image-20230331145011017](.\image\image-20230331145011017.png)

#### 6.环境变量

+ 能够找出你的linux服务器上的各种变量，**PATH** 

+ 每个用户都有自己的环境变量配置文件，**`~/.bash_profile`,`~/.bashrc` **

  ,且以给人配置文件优先加载变量，读取以个人的优先生效

+ 但你需要给所有用户都使用某个变量，写入全局即可**etc/profile**

#### 7. 查看变量的指令

+ **set** 输出当前shell所有变量，包括全局和sh脚本文件中定义的局部

+ **env**输出全局变量，不包括局部变量
+ **expore**输出环境变量
+ **declare**输出全部变量如同set
+ **unset 变量名** ，删除变量名
+ **readonly**只有shell结束，才能生效
+ bash支持多命令执行，分号隔开 如：**ls /apt; ls /etc/;cd my-work/**

#### 8.特殊参数变量学习

+ 例子 ./spec.sh 参数1 参数2 参数3 .... 参数n

  + 参数传递

    + $0获取文件名 
    + $1获取参数1
    + $2获取参数2

  + $#获取参数总个数

  + $@获取全部参数

  + $*获取全部参数

    ```shell
    #! /bin/bash
    echo '---特殊变量$0 $1 $2 $3 ...的实践'
    echo '结果： '$0 $1 $2 $3
    echo '####################'
    
    echo '---特殊变量$# 获取参数总个数'
    echo '结果： '$#
    echo '####################'
    
    echo '---特殊变量$* 获取参数'
    echo '结果： '$*
    echo '####################'
    
    
    echo '---特殊变量$@ 获取参数'
    echo '结果： '$@
    echo '####################'
    
    
    ```
    
    
    
    ![image-20230331175142596](.\image\image-20230331175142596.png)

+ `$*`和`$`@的区别当他们被“”包之后`$*`是把所有参数当一个整体，`$`@每一个参数都是独立的

+ ```shell
  #！ /bin/bsh
  
  echo "print each param from \"\$*\""
  for var in "$*"
  do 
     echo "$var"
  done
  
  echo "print each param from \"\$@\""
  for var in "$@"
  do
     echo "$var"
  done
  
  ```

+ 


​		 ![image-20230331163721281](.\image\image-20230331163721281.png)

#### 9.特殊状态变量

1. `$?`验证上次的命令的正确还是错的，正确0，不正确其他数字
   + 脚本返回值的控制,脚本返回值用**exit**
   + ![image-20230331172125560](.\image\image-20230331172125560.png)
2. `$$`当前shell脚本的进程号
   + 获取脚本的id号 **`$$`**
     1. ![image-20230331173020359](.\image\image-20230331173020359.png)
3. `$!`获取上次后台的PID
   + nohup 是让后台执行什么程序
   + 怎么让程序后台执行
     1. nohup xxx & 1> /dev/null
   + ![](.\image\image-20230331172620582.png)
4. `$_`取得上一次命令的最后一个参数

#### 10.bash一些内置命令

+ echo
  + -n 不换行输出
  + -e 解析字符串中的特殊符号
  + \n 换行
  + \r 回车
  + \t  制表符 两个空格
  + \b 退格

![image-20230403140651985](.\image\image-20230403140651985.png)

+ printf
+ eval 
+ exec 不创建子进程，执行后续命令，且执行完毕后，自动exit
  + ![image-20230403141315298](.\image\image-20230403141315298.png)



#### 11.shell子串的花式语法

+ **${变量}**  返回变量值

+ ${#变量}  返回变量长度，字符串长度

+ ${变量:start} 返回变量offset数值之后的字符

+ ${变量:start:length} 提出offset之后的length限制的字符

+ ${变量#word}  从变量开头删除最短匹配的word子串

+ ${变量##word} 从变量开头，删除最长匹配的word

+ ${变量%word} 从变量结尾删除最短的word

+ ${变量%%word} 从变量结尾开始删除最长匹配的word

+ ${变量/pattern/string} 用string代替第一个匹配的pattern

+ ${变量//pattern/string} 用string代替所有的pattern

+ 统计变量长度可以配wc，expr一起用

  + echo ${#name} 效率最高

  + echo ${name} |wc -l

  + echo ${name} |wc -L

  + expr length "$name"

  + echo ${name} | awk '{print length($name)}'

    ![image-20230403151002860](.\image\image-20230403151002860.png)

+ ${变量：-word} 如果变量值为空，返回word字符
+ ${变量:=word} 如果变量为空，则word替代变量值，且返回其值
+ ${变量:?word}如果变量位空，word当作stderr输出，否则输出变量值；用于设置变量为空导致错误是，返回错误信息
+ ${变量:+word}如果变量为空，什么都不做，否则word返回

#### 批量修改文件名

  + 利用变量的子串去掉后缀

  + ```shell
    #问题：去掉含有jia的所有文件名
    	#总体思路利用mv指令，for循环，反引号，字符串的替换
    #思考第一步，怎么修改文件名
    	#利用mv指令 mv zhongjiaji.jpg zhongji.jpg
    #思考第二部，如何用shell指令修改单个文件名
    	#利用字符串的替换
    	#name="zhongjiayi.jpg"
    	#mv echo ${name} `echo ${name\\*jia*.jpg}`
    #思考第三步，如何做到批量
    	#用到for循环，并且如何陈列出所有要包含jia的文件，用到ls指令陈列
    	#ls *jia*
    	#for xxx in xxx;do xxx;done
    #最后结果：
    for jpg_name in `ls *jia*`;do mv ${jpg_name} `echo ${jpg_name//jia/}`;done
    myzr@u14045:~/sub_str$ ls -l
    ```

#### 父子shell

1. source和.，执行脚本，只在当前的shell环境中执行生效
2. 指定sh bash解释器运行脚本，是开启subshell，开启shell运行脚本命令
3. ./script,都会指定shebang,通过解释器运行，开启subshell执行脚本



+ 在父shell，可以使用pstree

  ​      ├─sshd───sshd───sshd───bash───pstree

+ ps进程管理查看

  ps -ef --forest

+ 

+ ()括住命令执行，是用子shell执行的

+ 可以用echo $BASH_SUBSHELL查看shell的子进程有多少

+ ![image-20230406141031796](.\image\image-20230406141031796.png)



内置命令和外置命令

+ 概念
  + 外置命令：在系统启动时就会加载入内存中，常驻内存，执行效率高，但是占用资源，cd
  + 内置命令：系统需要从硬盘中读出程序文件，再读入内存加载
+ 外部命令一般在的路径/bin;/usr/bin;/sbin;/usr/sbin
+ type可以验证内置外置命令
+ 查看linux全部内置命令compgen -b
+ ![image-20230406143411526](.\image\image-20230406143411526.png)



shell开发

+ echo格式化打印
+ 转义符 用反斜杠\,还原符号原本的意思，不含特殊含义
+ 变量在脚本中的使用
  + 变量被引用的时候，会赋予值，脚本中的变量，在shell执行完毕后，就会消失，根据执行的方式
  + ![image-20230406151210748](.\image\image-20230406151210748.png)

（）开启子shell执行，和反引号效果一样

![image-20230406151611555](.\image\image-20230406151611555.png)

#### 10.语法参数

1. **-ne**

2. **-d**

3. **for**

   + 结构：

     ```shell
     for 变量 in 循环多少次
     do 
     	XXXXXXXXXXX
     done
     #例如：
     for name in {0..20};do echo $name;done
     
     ```
   
   + time for n in {1..10000};do char=`seq -s "zhongjiayi" 100`;echo ${char}|wc -L &>/dev/null;done
   
      ​	












## html

### 1. 表格 

| `<table></table>`       | 定义表格，生成的表格在一对`<table></table>`中；              |
| ----------------------- | ------------------------------------------------------------ |
| `<caption></caption>`   | 定义表格标题，当表格需要标题时，使用`<caption>表格标题</caption>` |
| `<thead></thead>`       | 定义表格的页眉                                               |
| `<tbody></tbody>`       | 定义表格的主体                                               |
| `<tfoot></tfoot>`       | 定义表格的页脚                                               |
| `<th></th>`             | 定义表格的表头，一般是表头中的内容会被加黑                   |
| `<td></td>`             | 定义表格单元格                                               |
| `<tr></tr>`             | 定义表格的行                                                 |
| `<col></col>`           | 定义用于表格列的属性                                         |
| `<colgroup></colgroup>` | 定义表格列的组                                               |



<table border="10" cellspacing="8" style="width:500px" align="left"   rules="none" background='https://p1.ssl.qhimgs1.com/sdr/400__/t01f04c2504aa62bab7.gif'>
  <!--边框大小border-->
    <!--背景图片background-->
    <!-- frame="rows"-->
    <caption>caption表头</caption>
    <thead align="center">thead页眉</thead>
  <tr align="center">
​   <th colspan="3">表格所在的位置</th>
  </tr>
   <!--#表格所在的位置 -->
   <!--th加黑 td不加黑 -->
  <tr align="left">
​    <th >align="center"</th>
     <th >align="left"</th>
     <th >align="right"</th>
  </tr>
  <tr align="right">
   <!--单元格颜色不bgcolor-->
​  <td colspan="2" bgcolor='red'>colspan横组合表格</td>
   <td rowspan="2">rowspan竖组合表格</td>  
  </tr>
  <tr align="center">
	<td colspan="2">colspan横组合表格</td>
  </tr>
    <tfoot></tfoot>
</table>







​      



​    

## matlab

1. 已知点，求函数

   1. 可以用拟合工具如下图
   2. ![image-20230505143847926](.\image\image-20230505143847926.png)
   3. 在窗口中输入函数的值如x=[1 2 3] y=[1 2 3],具体操作如图
   4. ![image-20230505144552518](.\image\image-20230505144552518.png)
2. 已知函数，求点
   1. 现在窗口写下函数，指数函数如图
      <img src=".\image\image-20230505141024272.png" alt="image-20230505141024272" style="zoom:100%;" />
   2. 求函数a-b段的范围值，x=[a:b]，再打上函数y，既可以打印出对应的值在窗口














## Linux ##

### 1. <font size="4">常用指令</font>

#### tail

```cobol
chsh -s /bin/zsh
```

#### find

+ find xargs 搜索且删除
+ find 目录 -name 文件名字  按名字搜索
+ find 目录 -type文件类型 按文件类型搜索
+ find 目录 -mtime 时间  修改时间

#### ps -ef|grep ssshd

#### wc

#### cat

#### head 

#### &>/dev/null

+ 定向输出到无底洞，即不做任何显示，

#### history

+ history -c清空记录
+ history -r恢复记录
+ 记录存放在 /bash_histor
+ !! 可以执行上一条命令
+ ！+[history记录编号]，快速执行命令
+ ![image-20230328172507951](.\image\image-20230328172507951.png)



#### dmesg

+ 用于显示开机信息

#### cp

+ 复制文件

+ <font color=redpink>cp [被复制文件 ] [复制的文件]</font>  复制单个文件

+ <font color=redpink>cp -r [被复制的文件夹/*] [复制到的文件夹] </font>复制一整个文件夹

  

#### df

+ 查看设备存储状况



#### echo

+ echo  XXXX(要输出的字符) ，打印输出的字符

+ ```shell
  echo "`ifconfig`"  格式化打印网络信息=同于ifconfig单独命令
  ```



#### grep

+ <font color=redpink>grep -[参数]  [查找的单词]  [文本名字]</font>
+ 文本搜索工具并把匹配的行打印出来
+ --color  把查找的单词标颜色
+ -n     标注字符所在的行数
+ -i      不区分大小
+ -v      显示不包含查找的字符
+ -o      只显示需要查找的字符
+ -e       多个字符查找
+ -w     查找单独的单词，不包含其他字母数字，
+ -C3    显示要查找的字符所在行数的前后3行
+ -A1    显示要查找的字符所在行数的后1行
+ -B1    显示要查找的字符所在行数的前1行
+ -c       显示个数，在这个文档中总共有多少个

+ 列子：查找文件里面的内容
+ grep "wm8" * -R
  grep "wm8" *8m* -R
  grep "wm8" *8mm* -R

#### git

+ git add ./git add -A 把修改了的提交至缓存

+ git fetch --all 可以更新拉取最新的远程仓库

+ git commit -m "XXXXXXXXX" 提交版本到仓库

+ git diff 查找修改的内容

+ git status . 查看修改了什么

+ git pull origin

+ git reset --hard HEAD

  + git reset XXXXX版本号 切换到某个版本
  + 切换过去之后 用Git status .查看修改了什么
  + 在用还原git reset --hard HEAD

+    删除某一个版本提交记录

  + git rebase -i ID
  + 进入界面把pick改成drop
  + 保存退出
  + 如果没有成功，并且回退到了ID版本
  + 继续操作 git add -A
  + git rebase --continue 
  + 进入界面在版本前面加上drop
  + 保存退出查看是否删除成功

+ git fetch origin

+ git log/ git log XXXX (XXXXX)文件名

+ git checkout -- .

+ git clone XXXXXXXXXXX

  + 克隆ssh，需要在GitHub中添加ssh key

  + ```
    git config --global --list
    git config --global user.name "用户名" 
    git config --global user.email "用户邮箱"
    git config --global credential.helper store  
    ssh-keygen -t rsa -C ‘你的邮箱’
    ```

  + ![image-20230309103139411](.\image\image-20230309103139411.png)

![image-20230314160845026](.\image\image-20230314160845026.png)


+ ```
  //<your_token>生成的令牌，<USERNAME>，github的账号名，<REPO>要推送的仓库名
  
  git remote set-url origin https://<your_token>@github.com/<USERNAME>/<REPO>.git
  
   git remote set-url origin https://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@github.com/zhongdonggua/note_C.git
   
   执行完这个再执行
  git push origin master
  
  ```

+ git push origin master  推送回github，要在GitHub上先生成令牌，密码粘贴令牌

  <img src=".\image\image-20230308111426142.png" alt="image-20230308111426142" style="zoom:67%;" />

<img src=".\image\image-20230308111405152.png" alt="image-20230308111405152" style="zoom:67%;" />

<img src=".\image\image-20230308111308384.png" alt="image-20230308111308384" style="zoom:67%;" />

![image-20230308111226663](.\image\image-20230308111226663.png)

#### i2cdetect

+ i2cdetect -l 列举i2c 的所有总线
+ i2cdetect -y X (x是i2c 对应的总线)；  查询I2C总线功能
+ i2cdetect -F X  ;查询总线所实现的功能




#### ifconfig

+ 配置网络网口的命令
+ ifconfig  [网口]  [ip]  ，配置网口的ip   例如<font color="redpink">ifconfig  eth0 172.168.137.81</font>
+ ifconfig up/down  配置网口起或者下线



#### ln

+ 基本用到的是ln -s  [源文件或目录]   [目标文件或目录]    软连接



#### lsmod

+ 执行lsmod指令，会列出所有已载入系统的模块。



#### mkdir

+ 创建文件夹

#### mv

+ <font color="redpink">mv [移动的文件] [要移动到的地方]</font> 移动文件
+ <font color="redpink">mv [文件] [新文件名]</font>修改文件名

#### ping



#### pandoc

+ pandoc BM.启动手册.rst -f rst -t markdown o BM.启动手册.md
+ pandoc BM.启动手册.rst -f rst -t markdown -o BM.启动手册.md



#### source 





#### sync

+ 同步命令，在修改设备参数可以用来同步一下




#### sz

+ sz+文件名字 



#### tftp

+ <font color="redpink">tftp -gr xxxx[文件名] 电脑地址xxx.xxx.xx.xx </font>  把文件传进核心板

+ tftp -pr xxxx[文件名] 电脑地址xxx.xxx.xx.xx  从核心板传出文件



#### touch

+ 创建文件



#### tar

+ 压缩和解压文件
+ 压缩
  + <font color="redpink">tar -cf  [压缩文件名].tar 压缩的文件</font> ，压缩得到文件格式是tar
  + <font color="redpink">tar -cjf  [压缩文件名].tar.bz2  压缩的文件</font> ，压缩得到文件格式是bz2
  + <font color="redpink">tar -czf  [压缩文件名].tar.gz  压缩的文件</font>，压缩得到文件格式是gz
  + <font color="redpink">tar -cJf  [压缩文件名].tar.xz  压缩的文件</font>，压缩得到文件格式是xz
    + **-c**  创建的意思
    + **-f **生成的文件名
    + **-j -z -J** 分别对应bzip2、gzip、xz三种压缩的格式
+ 解压
  + <font color="redpink">tar -xf [压缩文件名].tar</font> 解压的文件名
  + <font color="redpink">tar -xjf [压缩文件名].tar.bz2 </font>解压的文件名
  + <font color="redpink">tar -xzf [压缩文件名].tar.gz </font>解压的文件名
  + <font color="redpink">tar -xJf [压缩文件名].tar.xz</font> 解压的文件名
    + **-x** 提取解压的意思 extrarc




#### wpa_supplicant 

+ wpa_supplicant -B -i wlan0 -D wext -c /etc/wpa_supplicant.conf 
  + -B 后台运行
  + -i   指定使用哪个wifi设备
  + -D 指定驱动名字
  + -c 指定wifi账号密码的保存文件
  + [更多参数参考](https://blog.csdn.net/qq_45274342/article/details/116450829?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167722515816782425150028%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167722515816782425150028&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-116450829-null-null.142^v73^control_1,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=wpa_passphrase%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187)




#### zip

+ 压缩
  + zip [压缩成的文件名].zip [文件名]
  + zip -r [压缩成的文件夹名].zip [文件夹]
+ 解压
  + unzip [压缩文件].zip



### 2. <font size="4">编译</font>

+ gcc xxx.c -o [文件名] 编译指令 
+ make mrproper 清空，为编译服务，清空了更加容易编译成功



### 3. 查看进程的指令

+ ps
+ top
+ man 

































## vscode

1. 快捷键：切回上一个光标处：alt+←

1. 搜索-->正则表达式匹配字符

   ![image-20230427092626469](.\image\image-20230427092626469.png)

   + `^\+.*\+$`	,`^查询开头，$查询结尾，\是表示特殊字符`
   + `^\|` 
   + `[ ]*\|`
   + 删除空行 
   + ![image-20230505151229792](.\image\image-20230505151229792.png)
   + 

2. alt+shift,可以多选同一列的字符

3. 设置编辑器默认打开的格式
	![image-20230427093219365](.\image\image-20230427093219365.png)





## imx8

### 开发板uboot文件

+ 1、板子8mini、8mq、8M Plus的引脚和原理图

  + MYZR-IMX8M-EK300 使用及开发指导
  + MYZR-IMX8M-CB300 硬件介绍
  + MYZR-IMX8M-MB300 硬件介绍
  + MYZR-IMX8M-EK300 Linux-4.14.98 测试手册
  + MYZR-IMX6-A9 Linux-3.14.52 编译参考手册 v2.0
  + MYZR-I.MX8M usage and development guide

+ 改变下图框着的文件需要重新编译Image文件，重新输入开发板

+ ![image-20230227151428388](.\image\image-20230227151428388.png)

+ 2、编译命令的理解

  + 编译内核

    + **1.生成目标文件.config**
      + <font color="redpink">make XXXXX_defconfig </font>（查找这个defconfig对应文件再\linux-X.XX.X\arch\arm64\configs的路径下）生成.config文件再进行make
        + make O=文件名 XXXXX_defconfig  指代把.o文件生成放进对应的文件里

    + **进入.config的目录，make -j24把下面两步的都生成了**
    + **2. 生成Image文件**
      + <font color="redpink">make Image -j24</font> 生成的文件在.\arch\arm64\boot这个目录下，编译信息最后一行是文件所在地
      + ![image-20230224090051827](.\image\image-20230224090051827.png)
      + 如果没有出现这行如下这说明此时的Image文件是最新的，没有做任何变更
      + ![image-20230223175746164](.\image\image-20230223175746164.png)
    + **3. 生成设备树dtb文件**
      + <font color="redpink">make XXXX.dtb </font>查看设备树dts所在的位置，例如myimx8mpek314.dts，在.\arch\arm64\boot\dts\myzr这个位置，则<font color="redpink">make myzr/myimx8mpek314.dtb</font>就能成功生成文件，具体生成的文件地址如下图，
      + ![image-20230223180241181](.\image\image-20230223180241181.png)
      + 如果没有出现这行，则说明此时的Image文件是最新的，没有做任何变更
      + ![image-20230223180359013](.\image\image-20230223180359013.png)
    + **4. 生成内核模块包**
      + <font color="redpink">make modules</font>
      + <font color="redpink">mkdir modules</font>
      + <font color="redpink">make modules_install INSTALL_MOD_PATH=./modules</font>
      + <font color="redpink">tar cjf kernel-modules.tar.bz2 -C modules lib</font>

+ 3、编译生成的具体有什么文件

  + 生成Image、XXX.dtb 、kernel-modules.tar.bz2
  + 三个文件，修改dts文件需要重新编译生成dtb文件

+ 4、编译环境的修改什么的？不记得要求什么，什么客户的环境不一样什么的

+ 5、myimx8mek300-8mq.bat命令的理解

  + @echo off

    start /b /wait ./uuu-files-L4.14.98/uuu.exe ./uuu-files-L4.14.98/myimx8mek300-8mq.uuu

    pause

+ 6、myimx8mek300-8mq.uuu,文件命令的理解

+ 7、 当需要修改环境的时候，可以修改此路径![image-20230222160059793](.\image\image-20230222160059793.png)

+ 3、cp myimx8mek300-8mq-tm_\(2\).dtb /run/media/mmcblk0p1/myimx8mek

+ myimx8mmek对照设备树，是对照所有的引脚是否对其并且所有的引脚是否引用



### U-BOOT

1. 进入u-boot

![image-20230201162653492](.\image\image-20230201162653492.png)

![image-20230201162716187](.\image\image-20230201162716187.png)

2. printenv查看环境变量信息

3. printenv fdt_file 查看当前用什么设备树

4. 修改了设备树之后，u-boot启动不了可以通过修改匹配的设备树重新启动

   ```shell 
   setenv fdt_file myimx8mek300-8mq.dtb   
   saveenv
   ```

​		搭配使用，setenv设置环境变量，saveen保存环境变量

5. u-boot相对重要的文件

   X:\work\\linux\imx-linux-5.10.72\uboot-2021.04\board\myzr\myimx8mm目录下的

​		myimx8mm.c

​		spl.c

 X:\work\\linux\imx-linux-5.10.72\uboot-2021.04\configs

对应make的设备树文件myimx8mmek200_defconfig

X:\work\\linux\imx-linux-5.10.72\uboot-2021.04\include\configs目录下放的的都是头文件



6. 手动挂载U盘

   + 当U盘加载成功，但是在mnt没有看到U盘相对应的文件，需要手动加载，手动加载命令如下

   ```shell
   mount /dev/sda1 /mnt/udisk
   ```

   





6.编译工具

+ 用服务器编译生成驱动文件，例如生成flash.bin

+ 把生成的flash.bin文件放在相应的目录uuu
+ <img src=".\image\image-20230228174235281.png" alt="image-20230228174235281"  />
+ 修改uuu文件，修改如下

![image-20230228173921181](.\image\image-20230228173921181.png)

![image-20230228174056182](.\image\image-20230228174056182.png)

![image-20230228173805781](.\image\image-20230228173805781.png)



+ 修改生成烧录工具脚本

![image-20230228174235281](.\image\image-20230228174235281.png)



![image-20230228174325610](.\image\image-20230228174325610.png)

![image-20230228174257761](.\image\image-20230228174257761.png)



### 调整音频

```shell
amixer -c 0 cset name='Left Input Mixer Boost Switch' 'on'
amixer -c 0 cset name='Left Output Mixer PCM Playback Switch' 'on'
amixer -c 0 cset name='Right Output Mixer PCM Playback Switch' 'on'
```

+ 添加相关的音频设置的参数，替换掉音频的相关参数

+ 命令：**alsamixer**可以进入相关的音频调试页面

+ 测试命令也有相对应的改变
+ aplay -D hw:2 /usr/share/sounds/alsa/Front_Center.wav 



### mkimage_imx8

+ 编译生成烧录文件

  + 1. 配置

       ```shell 
       DEPLOYDIR=iMX8M
       UBT_MAKE_DIR=${HOME}/work/linux/imx-linux-5.10.72/uboot-2021.04/build_myimx8mmek200
       install -m 0775 ${UBT_MAKE_DIR}/tools/mkimage ${DEPLOYDIR}/mkimage_uboot
       install -m 0644 ${UBT_MAKE_DIR}/spl/u-boot-spl.bin ${DEPLOYDIR}/
       install -m 0644 ${UBT_MAKE_DIR}/u-boot-nodtb.bin ${DEPLOYDIR}/
       install -m 0644 ${UBT_MAKE_DIR}/arch/arm/dts/myimx8mmek200.dtb ${DEPLOYDIR}/
       ```

    2. make SOC=iMX8MM dtbs=myimx8mmek200.dtb flash_ddr4_evk OUTIMG=boot-myimx8mmek200.bin

  + 生成配置文件



### uboot-2020.04

+ make O=build_myimx8mmek200 myimx8mmek200_defconfig
+ ln -s build_myimx8mmek200 build
+ cd build_myimx8mmek200 build
+  cp ../../mkimage-5.10.72/iMX8M/bl31.bin ./
+ cp ../../mkimage-5.10.72/iMX8M/ddr4_* ./
+ cp ../../mkimage-5.10.72/iMX8M/signed_* ./
+ make flash.bin -j24
+ 生成flash.bin文件



### 下载交叉编译工具



mkdir toolchain

mkdir toolchain/gcc-linaro

cd toolchain/gcc-linaro

wget https://releases.linaro.org/components/toolchain/binaries/7.5-2019.12/aarch64-linux-gnu/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz

tar -xf gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.tar.xz

```shell 
cat << EOF > ~/toolchain/gcc-linaro/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.sh
#!/bin/sh
export PATH=${HOME}/toolchain/gcc-linaro/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin:${PATH}
export ARCH=arm64
export CROSS_COMPILE=aarch64-linux-gnu-
EOF
```

chmod +x gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.sh

source ~/toolchain/gcc-linaro/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu.sh

```shell
 ${CROSS_COMPILE}gcc -v
 Using built-in specs.
COLLECT_GCC=aarch64-linux-gnu-gcc
COLLECT_LTO_WRAPPER=/home/zhongjy/toolchain/gcc-linaro/gcc-linaro-7.5.0-2019.12-x86_64_aarch64-linux-gnu/bin/../libexec/gcc/aarch64-linux-gnu/7.5.0/lto-wrapper
Target: aarch64-linux-gnu
Configured with: '/home/tcwg-buildslave/workspace/tcwg-make-release_0/snapshots/gcc.git~linaro-7.5-2019.12/configure' SHELL=/bin/bash --with-mpc=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu --with-mpfr=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu --with-gmp=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu --with-gnu-as --with-gnu-ld --disable-libmudflap --enable-lto --enable-shared --without-included-gettext --enable-nls --with-system-zlib --disable-sjlj-exceptions --enable-gnu-unique-object --enable-linker-build-id --disable-libstdcxx-pch --enable-c99 --enable-clocale=gnu --enable-libstdcxx-debug --enable-long-long --with-cloog=no --with-ppl=no --with-isl=no --disable-multilib --enable-fix-cortex-a53-835769 --enable-fix-cortex-a53-843419 --with-arch=armv8-a --enable-threads=posix --enable-multiarch --enable-libstdcxx-time=yes --enable-gnu-indirect-function --with-build-sysroot=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/sysroots/aarch64-linux-gnu --with-sysroot=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu/aarch64-linux-gnu/libc --enable-checking=release --disable-bootstrap --enable-languages=c,c++,fortran,lto --build=x86_64-unknown-linux-gnu --host=x86_64-unknown-linux-gnu --target=aarch64-linux-gnu --prefix=/home/tcwg-buildslave/workspace/tcwg-make-release_0/_build/builds/destdir/x86_64-unknown-linux-gnu
Thread model: posix
gcc version 7.5.0 (Linaro GCC 7.5-2019.12)
```







## 解决问题的方式



1. 没有找到，重新sudo apt  updata

![image-20230207120247583](.\image\image-20230207120247583.png)	

2. stack overflow

![image-20230207120045609](.\image\image-20230207120045609.png)



![image-20230207120155165](.\image\image-20230207120155165.png)

3. 报错圈起来的是相对应的报错的行数

![image-20230515150339385](.\image\image-20230515150339385.png)

















































